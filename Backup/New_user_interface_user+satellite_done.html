<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dynamic Tasking Platform — RAW Hotspots + Satellites</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <style>
    :root {
      --brand:#0b5; --accent:#2ecc71; --danger:#d9534f; --warn:#f0ad4e;
      --text:#111; --muted:#666; --bg:#f7f7f7; --card:#fff; --border:#e5e5e5;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:var(--text);background:#fff}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:var(--brand);color:#fff;font-weight:600;position:sticky;top:0;z-index:1000}

    #app{display:grid;grid-template-columns:1fr 380px;height:calc(100vh - 52px)}
    #map{width:100%;height:100%}
    #right{border-left:1px solid var(--border);overflow:auto;background:var(--bg)}

    .panel{background:var(--card);border-bottom:1px solid var(--border);padding:12px 14px}
    .panel h3{margin:0 0 8px;font-size:16px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .row>*{flex:0 0 auto}
    .muted{color:var(--muted);font-size:12px}
    .small-btn{padding:7px 10px;border:0;border-radius:6px;background:var(--brand);color:#fff;font-weight:600;cursor:pointer}
    .small-btn:disabled{opacity:.6;cursor:not-allowed}
    .danger{background:var(--danger)}
    .outline{background:#fff;color:var(--brand);border:1px solid var(--brand)}
    .ghost{background:#fff;color:#333;border:1px dashed var(--border)}

    #date-panel{position:fixed;left:10px;top:64px;z-index:1200;background:rgba(255,255,255,.96);border:1px solid var(--border);border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.12);padding:10px;font-size:13px;max-width:420px}
    #date-panel input[type="date"]{padding:6px 8px}

    #user-panel{position:fixed;top:64px;right:calc(380px + 16px);z-index:1200;background:rgba(255,255,255,.96);border:1px solid var(--border);border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.12);padding:10px;font-size:13px;min-width:320px}
    #sat-panel{position:fixed;top:64px;right:calc(380px + 16px);z-index:1200;background:rgba(255,255,255,.98);border:1px solid var(--border);border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,.16);padding:10px;font-size:13px;min-width:360px;display:none}

    @media (max-width:1200px){#app{grid-template-columns:1fr 320px}#user-panel,#sat-panel{right:calc(320px + 16px)}}
    @media (max-width:980px){#user-panel,#sat-panel{left:10px;right:auto;top:220px;width:360px}}

    #selected-list{width:100%;border-collapse:collapse;font-size:12px}
    #selected-list th,#selected-list td{border-bottom:1px solid var(--border);padding:6px 6px;text-align:left}
    #selected-list th{position:sticky;top:0;background:var(--bg);z-index:1}
    #selected-list input[type=number]{width:72px;padding:4px}
    #selected-list .check-cell{width:26px;text-align:center;}

    .badge{display:inline-block;padding:2px 6px;border-radius:4px;background:#eee;font-size:12px}
    .legend-inline{background:#fff;border:1px solid var(--border);border-radius:8px;padding:6px 8px;box-shadow:0 1px 3px rgba(0,0,0,.06)}
    .legend-item{display:flex;align-items:center;gap:8px;margin:4px 0}
    .dot{width:10px;height:10px;border-radius:50%;border:1px solid #0003;display:inline-block}

    .listbox{max-height:220px;overflow:auto;border:1px solid var(--border);border-radius:8px;padding:6px;background:#fff}
    .sat-item{display:flex;align-items:center;gap:8px;padding:4px 2px}
    .sat-chip{display:inline-block;padding:2px 6px;border-radius:8px;background:#f2f2f2;border:1px solid #e0e0e0;font-size:12px}
  </style>
</head>
<body>
<header>
  <div>Dynamic Tasking Platform — RAW Hotspots + Satellites</div>
</header>

<div id="app">
  <div id="map"></div>

  <aside id="right">
    <!-- Step 1: Targets -->
    <div class="panel">
      <h3>Selected Fire Points (per user)</h3>
      <div class="row" style="margin-bottom:8px">
        <button class="small-btn" id="btnSetAll12">Set All to 12h</button>
        <button class="small-btn outline" id="btnExportUser">Export current user CSV</button>
        <button class="small-btn danger" id="btnRemoveSelected">Remove selected</button>
        <button class="small-btn danger outline" id="btnClearAll">Clear all</button>
      </div>
      <table id="selected-list">
        <thead>
        <tr>
          <th class="check-cell"><input type="checkbox" id="checkAllRows" title="Select / unselect all"/></th>
          <th>#</th><th>Lat</th><th>Lon</th><th>Fire Count</th><th>Freq (h)</th><th>Action</th>
        </tr>
        </thead>
        <tbody id="selected-tbody"></tbody>
      </table>

      <div class="row" style="margin-top:10px;justify-content:space-between;">
        <div class="muted">Step 1 of 2 — pick targets first.</div>
        <button class="small-btn" id="btnProceedSat" disabled>Proceed to Satellites…</button>
      </div>
    </div>

    <div class="panel">
      <h3>Add Custom Point</h3>
      <div class="row">
        <label>Lat <input type="number" id="customLat" step="0.00001" placeholder="e.g., -27.12345"/></label>
        <label>Lon <input type="number" id="customLon" step="0.00001" placeholder="e.g., 150.12345"/></label>
        <button class="small-btn" id="btnAddCustom">Add</button>
      </div>
    </div>

    <div class="panel">
      <h3>Export</h3>
      <div class="row">
        <button class="small-btn" id="btnExportAll">Export all users CSV</button>
        <span id="exportStatus" class="muted"></span>
      </div>
    </div>

    <div class="panel">
      <div><span class="badge">Status</span> <span id="sideStatus">Not loaded yet</span></div>
    </div>
  </aside>
</div>

<!-- Floating date panel -->
<div id="date-panel">
  <div style="font-weight:600;margin-bottom:4px;">Hotspots — filter by date (RAW points, Step 1)</div>
  <div class="row">
    <span class="muted">Data window: 2025-01-01 to 2025-01-07 (max 7 days). Grid-index tiles.</span>
  </div>
  <div class="row" style="margin-top:4px;">
    Start: <input type="date" id="startDate" min="2025-01-01" max="2025-01-07">
    End: <input type="date" id="endDate" min="2025-01-01" max="2025-01-07">
    <button class="small-btn" id="applyRange" disabled>Load</button>
  </div>
  <div class="legend-inline" style="margin-top:6px;">
    <div class="legend-item"><span class="dot" style="background:#f7c87a;"></span> RAW point</div>
    <div class="legend-item"><span class="dot" style="background:#2ecc71;"></span> Selected</div>
  </div>
  <div id="status" class="muted" style="margin-top:6px"></div>
</div>

<!-- Floating Step 1 panel (users & tools) -->
<div id="user-panel">
  <div style="font-weight:600;margin-bottom:6px;">Users & Tools — Step 1</div>
  <div class="row" style="margin-bottom:6px;">
    <label>User: <select id="userSelect"></select></label>
    <input type="text" id="newUserName" placeholder="New user name"/>
    <button class="small-btn" id="btnAddUser">Add User</button>
  </div>
  <div class="row" style="margin-top:4px;">
    <button class="small-btn" id="btnRectSelect">Select by Rectangle</button>
  </div>
</div>

<!-- Floating Step 2 panel (satellites) -->
<div id="sat-panel">
  <div style="display:flex;align-items:center;justify-content:space-between;">
    <div style="font-weight:600;">Satellites — Step 2</div>
    <div class="muted" id="satPlanHint">Plan Draft: 0 points</div>
  </div>

  <div class="row" style="margin-top:6px;">
    <span class="badge">Dates</span>
    <span id="satDates" class="muted">—</span>
  </div>

  <div class="row" style="margin-top:6px;">
    <label><input type="checkbox" id="chkShowTracks"/> Show ground track</label>
  </div>

  <div class="row" style="margin-top:6px;">
    <label>Default required interval (h)
      <input type="number" id="defaultInterval" min="1" step="1" value="4" style="width:72px;padding:5px"/>
    </label>
    <span class="muted">Per-point frequency overrides this.</span>
  </div>

  <div style="margin-top:6px;">
    <div class="muted" id="satSourceHint">Loading tracks/index.json…</div>
    <div class="listbox" id="satList" aria-label="Available satellites"></div>
  </div>

  <div class="row" style="margin-top:8px;justify-content:space-between;">
    <div>
      <button class="small-btn ghost" id="btnBackTargets">Back to Targets</button>
    </div>
    <div>
      <button class="small-btn outline" id="btnClearSats">Clear satellites</button>
      <button class="small-btn" id="btnExportTaskCSV">Export task request CSV</button>
      <button class="small-btn" id="btnExportScenario">Export scenario (JSON)</button>
    </div>
  </div>
</div>

<script>
  // ============================================================
  // Config
  // ============================================================
  const TILE_DIR = 'tiles';
  const TRACK_DIR = 'tracks';
  const MIN_DATE = '2025-01-01';
  const MAX_DATE = '2025-01-07';
  const MAX_DAYS = 7;

  // Globals loaded at boot
  let META = null;   // tiles meta
  let INDEX = null;  // tiles index
  let TRACK_INDEX = null; // tracks/index.json (per-day satellite availability)

  // Users / selections
  const users = {}; let currentUser = null;

  // Step 2: satellites
  const selectedSats = new Set();     // names
  let planDraftPoints = [];           // snapshot of user's selected points at step enter

  // Map and renderers
  const canvasRenderer = L.canvas({ padding: 0.2 });
  const map = L.map('map', { preferCanvas: true }).setView([-27.5, 150], 6);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 19, attribution: '&copy; OpenStreetMap & CARTO'
  }).addTo(map);

  // Rectangle select (Step 1)
  const drawnItems = new L.FeatureGroup(); map.addLayer(drawnItems);
  const drawControl = new L.Control.Draw({
    draw:{ polygon:false,circle:false,circlemarker:false,marker:false,polyline:false,
      rectangle:{repeatMode:false,showArea:false}},
    edit:{ featureGroup:drawnItems, edit:false, remove:true }
  });
  let drawEnabled = false;

  // Marker styles for RAW points
  function baseStyle(){ return { renderer: canvasRenderer, radius: 5, color: '#f39c12', fillColor: '#f7c87a', fillOpacity: 0.85, weight: 1 }; }
  function selectedStyle(){ return { renderer: canvasRenderer, radius: 6, color: '#2ecc71', fillColor: '#2ecc71', fillOpacity: 0.9, weight: 2 }; }
  const b = v => (v===undefined||v===null||v==='') ? '—' : v;

  // UTC date helpers
  function parseYMD_UTC(s){ const [y,m,d]=s.split('-').map(Number); return new Date(Date.UTC(y,m-1,d)); }
  function ymd_UTC(d){ return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`; }
  function daysBetweenInclusive(a,b){ const A=parseYMD_UTC(a), B=parseYMD_UTC(b); return Math.round((B-A)/86400000)+1; }

  // Grid helpers (tiles)
  function dLat(){ return (META.lat_max - META.lat_min) / META.ny; }
  function dLon(){ return (META.lon_max - META.lon_min) / META.nx; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function latToRow(lat){ let r=Math.floor((lat - META.lat_min)/dLat()); return clamp(r, 0, META.ny-1); }
  function lonToCol(lon){ let c=Math.floor((lon - META.lon_min)/dLon()); return clamp(c, 0, META.nx-1); }
  function rcRangeForBounds(bounds){
    const sw=bounds.getSouthWest(), ne=bounds.getNorthEast();
    let r0=latToRow(sw.lat), r1=latToRow(ne.lat); if(r1<r0)[r0,r1]=[r1,r0];
    let c0=lonToCol(sw.lng), c1=lonToCol(ne.lng); if(c1<c0)[c0,c1]=[c0,c1];
    return { r0, r1, c0, c1 };
  }

  // ============================================================
  // Tiles (RAW points) cache + bounded fetch queue
  // ============================================================
  const MAX_CONCURRENT_FETCHES = 10;
  const tileCache = new Map(); // date -> Map("r|c" -> entry)

  function dateCache(d){ if(!tileCache.has(d)) tileCache.set(d,new Map()); return tileCache.get(d); }
  function rcKey(r,c){ return r + '|' + c; }
  function tilePath(d,r,c){ return `${TILE_DIR}/${d}/r${r}_c${c}.json`; }

  const fetchQueue = []; let inflight = 0;
  function schedule(taskFn){ return new Promise((resolve,reject)=>{ fetchQueue.push({taskFn,resolve,reject}); pump(); }); }
  function pump(){
    while (inflight < MAX_CONCURRENT_FETCHES && fetchQueue.length){
      const {taskFn,resolve,reject} = fetchQueue.shift();
      inflight++;
      taskFn().then(v=>{ inflight--; pump(); resolve(v); })
              .catch(e=>{ inflight--; pump(); reject(e); });
    }
  }

  function idForPoint(date, lat, lon, time, idx){ const t=(time??'').toString().padStart(4,'0'); return `${date}|${t}|${lat}|${lon}|${idx}`; }
  function createMarker(pt){
    const m=L.circleMarker([pt.lat, pt.lon], baseStyle());
    m._rawId=pt.id;
    m.bindPopup(()=>`
      <div><b>RAW detection</b></div>
      <div>Date: ${b(pt.date)} Time: ${b(pt.time)}</div>
      <div>Brightness: ${b(pt.brightness)}</div>
      <div>Lat: ${pt.lat.toFixed(5)}, Lon: ${pt.lon.toFixed(5)}</div>
      <div style="margin-top:4px;"><em>Click to select/unselect.</em></div>
    `);
    m.on('click', () => togglePoint(pt.id));
    return m;
  }

  function loadTile(d,r,c){
    const cache=dateCache(d); const key=rcKey(r,c); const existed=cache.get(key);
    if (existed) return existed.promise;

    const entry={state:'loading', points:[], markers:[], layer:L.layerGroup(), added:false, promise:null};
    entry.promise = schedule(async()=>{
      const res=await fetch(tilePath(d,r,c), {cache:'force-cache'});
      if(!res.ok) throw new Error(`Tile not found ${d} r${r}_c${c} (${res.status})`);
      const js=await res.json();
      const raw=Array.isArray(js.points)?js.points:[];
      entry.points = raw.map((arr,i)=>{
        const lat=+arr[0], lon=+arr[1];
        const brightness=arr[2]??''; const time=arr[3]??'';
        return { id:idForPoint(d,lat,lon,time,i), date:d, lat, lon, brightness, time };
      });
      for (const pt of entry.points){
        const mk=createMarker(pt); entry.markers.push(mk); entry.layer.addLayer(mk);
      }
      entry.state='ready'; return entry;
    }).catch(err=>{ entry.state='error'; entry.error=err; throw err; });

    cache.set(key, entry); return entry.promise;
  }

  function addTile(entry){ if(!entry||entry.added||entry.state!=='ready')return; entry.layer.addTo(map); entry.added=true; restyleTileMarkers(entry); }
  function removeTile(entry){ if(!entry||!entry.added)return; try{ map.removeLayer(entry.layer);}catch(_){} entry.added=false; }
  function restyleTileMarkers(entry){
    const arr=users[currentUser]||[]; const sel=new Set(arr.map(s=>s.id));
    for (const mk of entry.markers){ mk.setStyle( sel.has(mk._rawId) ? selectedStyle() : baseStyle() ); }
  }
  function clearAllTiles(){
    for (const [,cache] of tileCache.entries()){ for (const [,entry] of cache.entries()){ removeTile(entry);} }
    tileCache.clear();
  }
  function unstyleMarkerById(id){
    for (const [,cache] of tileCache.entries()){
      for (const [,entry] of cache.entries()){
        if(!entry.added)continue;
        const mk=entry.markers.find(m=>m._rawId===id);
        if(mk){ mk.setStyle(baseStyle()); return true; }
      }
    }
    return false;
  }

  // Controller for RAW tiles
  const activeDates=[]; let refreshRAF=null;
  async function refreshTiles(){
    if(refreshRAF) cancelAnimationFrame(refreshRAF);
    refreshRAF = requestAnimationFrame(async()=>{
      if(!META||!INDEX) return;
      const bnds=map.getBounds(); const {r0,r1,c0,c1}=rcRangeForBounds(bnds);

      const needed=new Map();
      for (const d of activeDates){
        const set=new Set(); const avail=INDEX[d]||[]; const has=new Set(avail.map(x=>rcKey(x[0],x[1])));
        for(let r=r0;r<=r1;r++){ for(let c=c0;c<=c1;c++){ const key=rcKey(r,c); if(has.has(key)) set.add(key); } }
        needed.set(d,set);
      }

      const promises=[];
      for (const d of activeDates){
        const set=needed.get(d); const cache=dateCache(d);
        for (const key of set){ if(!cache.has(key)){ const [r,c]=key.split('|').map(Number); promises.push(loadTile(d,r,c)); } }
      }
      await Promise.allSettled(promises);

      let total=0, ready=0, active=0, visiblePts=0;
      for (const [d,cache] of tileCache.entries()){
        for (const [key,entry] of cache.entries()){
          total++; if(entry.state==='ready') ready++;
          const shouldOn = activeDates.includes(d) && needed.get(d)?.has(key);
          if(shouldOn && entry.state==='ready'){ addTile(entry); active++; visiblePts+=entry.points.length; }
          else { removeTile(entry); }
        }
      }
      document.getElementById('sideStatus').textContent =
        `Tiles ready: ${ready}/${total} | Active on map: ${active} | Visible RAW (tile sum): ${visiblePts.toLocaleString()}`;
    });
  }

  // ============================================================
  // Step 1: selection & sidebar
  // ============================================================
  function ensureUser(name){ if(!users[name]) users[name]=[]; }
  function togglePoint(id){
    if(!currentUser){ alert('Please add/select a user first.'); return; }
    ensureUser(currentUser);
    const arr=users[currentUser]; const idx=arr.findIndex(p=>p.id===id);

    let found=null;
    for (const [,cache] of tileCache.entries()){
      for (const [,entry] of cache.entries()){
        if(!entry.added) continue;
        const mk=entry.markers.find(m=>m._rawId===id);
        if(mk){ found=mk; break; }
      } if(found) break;
    }
    if(!found) return;
    const ll=found.getLatLng();

    if(idx===-1){ arr.push({ id, lat:ll.lat, lon:ll.lng, fire_count:1, frequency:null }); found.setStyle(selectedStyle()); }
    else { arr.splice(idx,1); found.setStyle(baseStyle()); }

    refreshSelectedList();
  }
  function enableRectangleSelection(){
    if(drawEnabled) return; drawEnabled=true; map.addControl(drawControl);
    const drawer=new L.Draw.Rectangle(map, drawControl.options.draw.rectangle); drawer.enable();
    function onCreated(e){
      const bounds=e.layer.getBounds(); let added=0; ensureUser(currentUser);
      for (const [,cache] of tileCache.entries()){
        for (const [,entry] of cache.entries()){
          if(!entry.added) continue;
          for (const mk of entry.markers){
            if(bounds.contains(mk.getLatLng())){
              const id=mk._rawId; const arr=users[currentUser];
              if(arr.findIndex(s=>s.id===id)===-1){
                const ll=mk.getLatLng(); arr.push({ id, lat:ll.lat, lon:ll.lng, fire_count:1, frequency:null });
                mk.setStyle(selectedStyle()); added++;
              }
            }
          }
        }
      }
      refreshSelectedList();
      alert(`Added ${added} RAW points to user "${currentUser}".`);
      map.off(L.Draw.Event.CREATED,onCreated); drawer.disable(); map.removeControl(drawControl); drawEnabled=false; drawnItems.clearLayers();
    }
    map.on(L.Draw.Event.CREATED,onCreated);
  }
  function refreshSelectedList(){
    const tbody=document.getElementById('selected-tbody'); tbody.innerHTML='';
    const arr=users[currentUser]||[];

    arr.forEach((p,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td class="check-cell"><input type="checkbox" class="row-check" data-id="${p.id}"/></td>
        <td>${i+1}</td>
        <td>${p.lat.toFixed(5)}</td>
        <td>${p.lon.toFixed(5)}</td>
        <td>${p.fire_count}</td>
        <td><input type="number" min="0" step="1" value="${p.frequency ?? ''}" data-id="${p.id}" class="freq-input" placeholder="e.g., 12"/></td>
        <td><button class="small-btn danger" data-id="${p.id}">Remove</button></td>`;
      tbody.appendChild(tr);
    });

    tbody.querySelectorAll('.freq-input').forEach(inp=>{
      inp.addEventListener('input',e=>{
        const id=e.target.getAttribute('data-id');
        const v=e.target.value===''?null:Math.max(0, Math.round(+e.target.value));
        const idx=(users[currentUser]||[]).findIndex(p=>p.id===id);
        if(idx!==-1) users[currentUser][idx].frequency=v;
      });
    });
    tbody.querySelectorAll('button.small-btn.danger').forEach(btn=>{
      btn.addEventListener('click',e=>{
        const id=e.target.getAttribute('data-id');
        const arr=users[currentUser]||[]; const idx=arr.findIndex(p=>p.id===id);
        if(idx!==-1){ arr.splice(idx,1); unstyleMarkerById(id); refreshSelectedList(); }
      });
    });

    const master=document.getElementById('checkAllRows'); if(master) master.checked=false;
    updateProceedButton();
  }
  function removeSelectedRows(){
    const tbody=document.getElementById('selected-tbody');
    const ids=Array.from(tbody.querySelectorAll('.row-check:checked')).map(cb=>cb.getAttribute('data-id'));
    if(!ids.length) return;
    const set=new Set(ids); const arr=users[currentUser]||[];
    for (const id of set) unstyleMarkerById(id);
    users[currentUser]=arr.filter(p=>!set.has(p.id));
    refreshSelectedList();
  }
  function clearAllRows(){
    if(!currentUser) return; const arr=users[currentUser]||[]; if(!arr.length) return;
    const ok=confirm(`Remove ALL ${arr.length} points for user "${currentUser}"?`); if(!ok) return;
    for (const p of arr) unstyleMarkerById(p.id); users[currentUser]=[]; refreshSelectedList();
  }

  function toCSV(rows){ const esc=s=>'"'+String(s).replace(/"/g,'""')+'"'; return rows.map(r=>r.map(esc).join(',')).join('\n'); }
  function downloadCSV(filename, rows){ const blob=new Blob([toCSV(rows)],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url); }
  function exportCurrentUser(){
    if(!currentUser){ alert('Please select a user.'); return; }
    const rows=[['username','lat','lon','fire_count','frequency_hours']];
    for (const p of (users[currentUser]||[])) rows.push([currentUser, p.lat, p.lon, p.fire_count, p.frequency ?? '' ]);
    downloadCSV(`${currentUser}_selected_raw_points.csv`, rows);
  }
  function exportAllUsers(){
    const rows=[['username','lat','lon','fire_count','frequency_hours']];
    for (const [uname,arr] of Object.entries(users)){ for (const p of arr) rows.push([uname, p.lat, p.lon, p.fire_count, p.frequency ?? '' ]); }
    downloadCSV(`selected_raw_points_by_user.csv`, rows);
    document.getElementById('exportStatus').textContent = `Exported ${rows.length-1} rows.`;
  }

  // Step 1 UI wiring
  function refreshUserDropdown(){
    const sel=document.getElementById('userSelect'); const prev=sel.value; sel.innerHTML='';
    Object.keys(users).forEach(u=>{ const opt=document.createElement('option'); opt.value=u; opt.textContent=u; sel.appendChild(opt); });
    if(users[prev]) sel.value=prev;
    if(!sel.value && Object.keys(users).length) sel.value=Object.keys(users)[0];
    currentUser=sel.value||null; refreshSelectedList();
    for (const [,cache] of tileCache.entries()){ for (const [,entry] of cache.entries()){ if(entry.added) restyleTileMarkers(entry); } }
  }
  document.getElementById('btnAddUser').addEventListener('click',()=>{
    const name=(document.getElementById('newUserName').value||'').trim();
    if(!name){ alert('Please type a user name.'); return; }
    if(users[name]){ alert('User already exists.'); return; }
    users[name]=[]; document.getElementById('newUserName').value=''; refreshUserDropdown();
  });
  document.getElementById('userSelect').addEventListener('change', e=>{
    currentUser=e.target.value||null; refreshSelectedList();
    for (const [,cache] of tileCache.entries()){ for (const [,entry] of cache.entries()){ if(entry.added) restyleTileMarkers(entry); } }
  });
  document.getElementById('btnRectSelect').addEventListener('click', ()=>{
    if(!currentUser){ alert('Please add/select a user first.'); return; }
    enableRectangleSelection();
  });
  document.getElementById('btnSetAll12').addEventListener('click', ()=>{ if(!currentUser) return; (users[currentUser]||[]).forEach(p=>p.frequency=12); refreshSelectedList(); });
  document.getElementById('btnExportUser').addEventListener('click', exportCurrentUser);
  document.getElementById('btnExportAll').addEventListener('click', exportAllUsers);
  document.getElementById('btnRemoveSelected').addEventListener('click', removeSelectedRows);
  document.getElementById('btnClearAll').addEventListener('click', clearAllRows);
  document.getElementById('checkAllRows').addEventListener('change', e=>{
    const checked=e.target.checked; document.querySelectorAll('#selected-tbody .row-check').forEach(cb=>cb.checked=checked);
  });

  // Date range apply (Step 1)
  document.getElementById('applyRange').addEventListener('click', async ()=>{
    const start=(document.getElementById('startDate').value||'').trim();
    const end=(document.getElementById('endDate').value||'').trim();
    const statusEl=document.getElementById('status');
    if(!start||!end){ statusEl.innerHTML='<span class="error">Please choose both start and end dates.</span>'; return; }
    if(start<MIN_DATE||end>MAX_DATE||start>end){ statusEl.innerHTML='<span class="error">Dates out of range or invalid.</span>'; return; }
    if(daysBetweenInclusive(start,end) > MAX_DAYS){ statusEl.innerHTML=`<span class="error">Range must not exceed ${MAX_DAYS} days.</span>`; return; }

    if(currentUser && (users[currentUser]?.length||0)>0){
      const ok=confirm('Switching the date window will reload tiles. Clear selections for the current user?');
      if(ok){ users[currentUser]=[]; refreshSelectedList(); }
    }

    // Build activeDates
    activeDates.length=0;
    for(let d=parseYMD_UTC(start); d<=parseYMD_UTC(end); d.setUTCDate(d.getUTCDate()+1)){
      const s=ymd_UTC(d); if(INDEX[s]) activeDates.push(s);
    }

    // Update Step 2 dates text
    document.getElementById('satDates').textContent = `${start} → ${end}`;
    // Rebuild satellite list for Step 2 (if TRACK_INDEX ready)
    buildSatelliteList();

    clearAllTiles();
    document.getElementById('sideStatus').textContent='Loading tiles...';
    statusEl.textContent=`Dates: ${start} → ${end} | Grid ${META.nx}×${META.ny}`;

    const bounds=L.latLngBounds([META.lat_min, META.lon_min],[META.lat_max, META.lon_max]);
    map.fitBounds(bounds.pad(0.1));

    await refreshTiles();
    rebuildTracksOnMap(); // ensure tracks follow the new window
  });

  // Proceed to Step 2
  document.getElementById('btnProceedSat').addEventListener('click', ()=>{
    // Snapshot user's current selection as the plan draft (deep copy)
    planDraftPoints = JSON.parse(JSON.stringify(users[currentUser] || []));
    document.getElementById('satPlanHint').textContent = `Plan Draft: ${planDraftPoints.length} points`;
    document.getElementById('user-panel').style.display='none';
    document.getElementById('sat-panel').style.display='block';
  });
  document.getElementById('btnBackTargets').addEventListener('click', ()=>{
    document.getElementById('sat-panel').style.display='none';
    document.getElementById('user-panel').style.display='block';
  });

  function updateProceedButton(){
    const cnt=(users[currentUser]||[]).length;
    const btn=document.getElementById('btnProceedSat');
    btn.disabled = cnt<=0;
  }

  // ============================================================
  // Step 2: Satellites (tracks)
  // ============================================================
  // Color per satellite (deterministic HSL hash)
  function satColor(name){
    let h=0; for(let i=0;i<name.length;i++){ h=(h*31 + name.charCodeAt(i)) % 360; }
    return `hsl(${h},70%,45%)`;
  }

  // tracks cache: key = date|sat
  const trackCache = new Map(); // key -> {state, layer, segmentsCount, promise}
  function trackKey(date, sat){ return `${date}|${sat}`; }
  function trackPath(date, sat){ return `${TRACK_DIR}/${date}/${encodeURIComponent(sat)}.json`; }

  function loadTrack(date, sat){
    const key=trackKey(date,sat); const existed=trackCache.get(key);
    if(existed) return existed.promise;

    const entry={state:'loading', layer:L.layerGroup(), promise:null};
    entry.promise = schedule(async()=>{
      const res=await fetch(trackPath(date,sat), {cache:'force-cache'});
      if(!res.ok) throw new Error(`Track not found ${date} ${sat} (${res.status})`);
      const js=await res.json();
      const color=satColor(sat);
      let segs=Array.isArray(js.segments)?js.segments:[];
      let count=0;
      for (const seg of segs){
        const latlngs = seg.map(p => [ +p[0], +p[1] ]);
        count += latlngs.length;
        const pl = L.polyline(latlngs, {renderer:canvasRenderer, weight:2, opacity:0.9, color});
        pl.bindTooltip(`${sat} ${date}`, {sticky:true});
        entry.layer.addLayer(pl);
      }
      entry.segmentsCount = count;
      entry.state='ready';
      return entry;
    }).catch(err=>{ entry.state='error'; entry.error=err; throw err; });

    trackCache.set(key, entry); return entry.promise;
  }
  function addTrack(entry){ if(!entry||entry.state!=='ready') return; if(map.hasLayer(entry.layer)) return; entry.layer.addTo(map); }
  function removeTrack(date, sat){
    const key=trackKey(date,sat); const entry=trackCache.get(key);
    if(!entry) return; try{ map.removeLayer(entry.layer);}catch(_){} }

  function clearAllTrackLayers(){
    for (const entry of trackCache.values()){
      try { map.removeLayer(entry.layer); } catch(_) {}
    }
  }

  function rebuildTracksOnMap(){
    const show = document.getElementById('chkShowTracks').checked;

    // Always clear first to handle unchecking properly
    clearAllTrackLayers();

    if (!show || selectedSats.size === 0 || activeDates.length === 0) return;

    const promises = [];
    for (const d of activeDates){
      for (const sat of selectedSats){
        promises.push(loadTrack(d, sat));
      }
    }
    Promise.allSettled(promises).then(()=>{
      for (const d of activeDates){
        for (const sat of selectedSats){
          const entry=trackCache.get(trackKey(d,sat));
          if(entry && entry.state==='ready') addTrack(entry);
        }
      }
    });
  }

  // Build satellites list (union over activeDates from TRACK_INDEX)
  function buildSatelliteList(){
    const box=document.getElementById('satList');
    const hint=document.getElementById('satSourceHint');
    box.innerHTML='';
    if(!TRACK_INDEX){
      hint.innerHTML = '<span class="muted">tracks/index.json not loaded. Ground tracks unavailable.</span>';
      return;
    }
    if(activeDates.length===0){
      hint.textContent = 'Pick dates in Step 1 first.';
      return;
    }
    const set=new Set();
    for (const d of activeDates){
      const arr=TRACK_INDEX[d]||[];
      for (const s of arr) set.add(s);
    }
    if(set.size===0){
      hint.textContent = 'No tracks available for chosen dates.';
      return;
    }
    hint.textContent = 'Select satellites to overlay ground tracks:';
    const sats=[...set].sort((a,b)=>a.localeCompare(b));
    for (const s of sats){
      const row=document.createElement('div'); row.className='sat-item';
      const color=satColor(s);
      row.innerHTML = `
        <label style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" class="sat-check" value="${s}"/>
          <span class="sat-chip" style="border-color:${color};color:${color}">${s}</span>
        </label>`;
      box.appendChild(row);
    }
    box.querySelectorAll('.sat-check').forEach(cb=>{
      cb.addEventListener('change', e=>{
        const name=e.target.value;
        if(e.target.checked) selectedSats.add(name); else selectedSats.delete(name);
        rebuildTracksOnMap();
      });
    });
  }

  // Step 2 controls
  document.getElementById('chkShowTracks').addEventListener('change', rebuildTracksOnMap);
  document.getElementById('btnClearSats').addEventListener('click', ()=>{
    selectedSats.clear();
    document.querySelectorAll('#satList .sat-check').forEach(cb=>cb.checked=false);
    rebuildTracksOnMap();
  });

  // Export scenario JSON (kept for convenience)
  document.getElementById('btnExportScenario').addEventListener('click', ()=>{
    const dates = (function(){
      if(activeDates.length===0) return [MIN_DATE, MAX_DATE];
      const s=activeDates[0], e=activeDates[activeDates.length-1];
      return [s,e];
    })();
    const obj={
      generated_at: new Date().toISOString(),
      user: currentUser,
      date_window: { start: dates[0], end: dates[1] },
      satellites: Array.from(selectedSats),
      points: planDraftPoints
    };
    const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`scenario_${currentUser||'user'}_${dates[0]}_${dates[1]}.json`; a.click();
    URL.revokeObjectURL(url);
  });

  // Export task request CSV (your requested schema)
  document.getElementById('btnExportTaskCSV').addEventListener('click', ()=>{
    if(!currentUser){ alert('Please select a user.'); return; }
    if(planDraftPoints.length===0){ alert('No points in Plan Draft. Go back to Step 1 and select points.'); return; }
    if(activeDates.length===0){ alert('Please choose a date range in Step 1.'); return; }

    const start = activeDates[0];
    const end   = activeDates[activeDates.length-1];

    const satArr = Array.from(selectedSats);
    const satsStr = satArr.join(';');

    const def = Math.max(1, Math.floor(+document.getElementById('defaultInterval').value || 4));

    const rows = [[
      'user','window_start_utc','window_end_utc','satellites',
      'point_id','lat','lon','required_interval_hours'
    ]];

    for (const p of planDraftPoints){
      const req = (p.frequency==null || p.frequency==='') ? def : p.frequency;
      rows.push([
        currentUser, start, end, satsStr,
        p.id, p.lat, p.lon, req
      ]);
    }

    downloadCSV(`task_request_${currentUser||'user'}_${start}_${end}.csv`, rows);
  });

  // ============================================================
  // Boot
  // ============================================================
  (async function boot(){
    try{
      const [m,i] = await Promise.all([
        fetch(`${TILE_DIR}/meta.json`, {cache:'no-cache'}).then(r=>r.json()),
        fetch(`${TILE_DIR}/index.json`, {cache:'no-cache'}).then(r=>r.json())
      ]);
      META=m; INDEX=i;
      document.getElementById('status').textContent = `Grid loaded: nx=${META.nx}, ny=${META.ny}`;
      document.getElementById('applyRange').disabled = false;
    }catch(e){
      document.getElementById('status').innerHTML = `<span class="error">Failed to load tiles meta/index</span>`;
      console.error(e);
    }

    // Try loading tracks index (optional)
    try{
      const t = await fetch(`${TRACK_DIR}/index.json`, {cache:'no-cache'});
      if(t.ok){ TRACK_INDEX = await t.json(); document.getElementById('satSourceHint').textContent='Tracks index loaded.'; }
      else { document.getElementById('satSourceHint').textContent='tracks/index.json not found.'; }
    }catch(e){
      document.getElementById('satSourceHint').textContent='tracks/index.json not found.';
      console.warn('Tracks index load failed', e);
    }

    users['User1']=[]; currentUser='User1'; refreshUserDropdown();
    const s=document.getElementById('startDate'), e=document.getElementById('endDate');
    if(s) s.value=MIN_DATE; if(e) e.value=MAX_DATE;

    map.on('moveend', refreshTiles);
    map.on('zoomend', refreshTiles);
  })();
</script>
</body>
</html>
