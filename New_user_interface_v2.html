<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WP4: Dynamic Tasking Platform</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <style>
    :root{
      --brand:#1f6fe5;
      --brand-dark:#184fb0;
      --accent:#2ecc71;
      --warn:#f7c87a;
      --danger:#e55353;
      --text:#0f1a2b;
      --muted:#6e7b8f;
      --bg:#f3f6fb;
      --card:#ffffff;
      --border:#e1e6f0;
      --custom:#6c5ce7; /* purple for custom points */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);background:#fff}

    header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:var(--brand);color:#fff;font-weight:700;letter-spacing:.2px;position:sticky;top:0;z-index:1000}

    #app{display:grid;grid-template-columns:1fr 380px;height:calc(100vh - 56px)}
    #map{width:100%;height:100%}
    #right{border-left:1px solid var(--border);overflow:auto;background:var(--bg)}

    .panel{background:var(--card);border-bottom:1px solid var(--border);padding:12px 14px}
    .panel h3{margin:0 0 8px;font-size:16px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .row>*{flex:0 0 auto}
    .muted{color:var(--muted);font-size:12px}
    .small-btn{padding:7px 12px;border:0;border-radius:8px;background:var(--brand);color:#fff;font-weight:600;cursor:pointer;box-shadow:0 2px 0 var(--brand-dark)}
    .small-btn:hover{filter:brightness(.97)}
    .small-btn:disabled{opacity:.55;cursor:not-allowed;box-shadow:none}
    .danger{background:var(--danger);box-shadow:0 2px 0 #b73b3b}
    .outline{background:#fff;color:var(--brand);border:1px solid var(--brand)}
    .ghost{background:#fff;color:#2b3a55;border:1px dashed var(--border)}

    #wizard{position:fixed;top:68px;right:calc(380px + 16px);z-index:1200;background:rgba(255,255,255,.98);border:1px solid var(--border);border-radius:14px;box-shadow:0 8px 28px rgba(21,32,56,.18);padding:12px;min-width:380px;max-width:460px}
    #wizard h4{margin:4px 0 8px}
    #steps{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:6px}
    .step-pill{padding:4px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;font-size:12px}
    .step-pill.active{background:var(--brand);color:#fff;border-color:var(--brand)}
    .step-pill.done{background:#e7f0ff;color:#11408a;border-color:#c9dcff}
    .wizard-nav{display:flex;justify-content:space-between;margin-top:8px}

    @media (max-width:1200px){#app{grid-template-columns:1fr 320px}#wizard{right:calc(320px + 16px)}}
    @media (max-width:980px){#wizard{left:10px;right:auto;top:10px;width:min(96vw,440px)}}

    #selected-list{width:100%;border-collapse:collapse;font-size:12px}
    #selected-list th,#selected-list td{border-bottom:1px solid var(--border);padding:6px 6px;text-align:left}
    #selected-list th{position:sticky;top:0;background:var(--bg);z-index:1}
    #selected-list input[type=number]{width:80px;padding:4px;border:1px solid var(--border);border-radius:6px}
    #selected-list .check-cell{width:26px;text-align:center;}

    .legend-inline{background:#fff;border:1px solid var(--border);border-radius:10px;padding:8px 10px;box-shadow:0 1px 3px rgba(0,0,0,.06)}
    .legend-item{display:flex;align-items:center;gap:8px;margin:4px 0}
    .dot{width:10px;height:10px;border-radius:50%;border:1px solid #0002;display:inline-block}

    .listbox{max-height:230px;overflow:auto;border:1px solid var(--border);border-radius:10px;padding:8px;background:#fff}
    .sat-item{display:flex;align-items:center;gap:8px;padding:4px 2px}
    .sat-chip{display:inline-block;padding:2px 8px;border-radius:999px;background:#f3f6fb;border:1px solid #dfe7f7;font-size:12px}

    /* Cover page */
    #cover{
      position:fixed;inset:0;z-index:2000;display:flex;flex-direction:column;align-items:center;justify-content:center;
      background: radial-gradient(1200px 600px at 30% 20%, #2b6ddf 0%, #144a9a 45%, #0e356f 100%);
      color:#fff;text-align:center;padding:32px;
    }
    #cover h1{font-size:42px;line-height:1.2;margin:0 0 12px;font-weight:800;letter-spacing:.3px}
    #cover p{opacity:.92;margin:0 0 20px}
    #cover .enter{padding:12px 22px;border:0;border-radius:10px;background:#fff;color:#0f2f73;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.25)}
    #cover .enter:hover{filter:brightness(.96)}
    .hidden{display:none !important}

    /* Done modal */
    .overlay{position:fixed;inset:0;background:rgba(10,20,40,.45);backdrop-filter:blur(2px);z-index:2200}
    .dialog{position:fixed;inset:auto;left:50%;top:20vh;transform:translateX(-50%);z-index:2210;background:#fff;border:1px solid var(--border);border-radius:14px;box-shadow:0 16px 40px rgba(8,16,32,.25);padding:16px;min-width:360px;max-width:90vw}
    .dialog h4{margin:0 0 8px}
    .dialog .footer{display:flex;justify-content:flex-end;gap:8px;margin-top:12px}
  </style>
</head>
<body>
  <!-- Cover -->
  <div id="cover" aria-label="Cover">
    <h1>ðŸ”¥ WP4: Dynamic Tasking Platform ðŸ”¥</h1>
    <p>ðŸ”¥ Use-case: Dynamic Planning for Fire Monitoring Tasks ðŸ”¥</p>
    <button class="enter" id="btnEnter">Enter Platform</button>
  </div>

  <header>
    <div>Dynamic Tasking Platform â€” RAW Hotspots + Satellites (Wizard)</div>
  </header>

  <div id="app">
    <div id="map"></div>

    <!-- Right sidebar -->
    <aside id="right">
      <div class="panel">
        <h3>Selected Fire Points (per user)</h3>
        <div class="row" style="margin-bottom:8px">
          <button class="small-btn" id="btnSetAll12">Set All to 12h</button>
          <button class="small-btn outline" id="btnExportUser">Export current user CSV</button>
          <button class="small-btn danger" id="btnRemoveSelected">Remove selected</button>
          <button class="small-btn ghost" id="btnClearAll">Clear all</button>
        </div>
        <table id="selected-list">
          <thead>
          <tr>
            <th class="check-cell"><input type="checkbox" id="checkAllRows" title="Select / unselect all"/></th>
            <th>#</th><th>Lat</th><th>Lon</th><th>Fire Count</th><th>Freq (h)</th><th>Action</th>
          </tr>
          </thead>
          <tbody id="selected-tbody"></tbody>
        </table>
        <div class="muted" style="margin-top:6px">Tip: Click RAW points to toggle; <b>rightâ€‘click</b> empty map to add a custom point. Click a purple point to edit.</div>
      </div>

      <div class="panel">
        <h3>Add Custom Point</h3>
        <div class="row">
          <label>Lat <input type="number" id="customLat" step="0.00001" placeholder="e.g., -27.12345"/></label>
          <label>Lon <input type="number" id="customLon" step="0.00001" placeholder="e.g., 150.12345"/></label>
          <button class="small-btn" id="btnAddCustom">Add</button>
        </div>
      </div>

      <div class="panel">
        <h3>Export (raw selections)</h3>
        <div class="row">
          <button class="small-btn" id="btnExportAll">Export all users CSV</button>
          <span id="exportStatus" class="muted"></span>
        </div>
      </div>

      <div class="panel">
        <div><span class="muted">Tiles/Tracks status:</span> <span id="sideStatus">Not loaded yet</span></div>
      </div>
    </aside>
  </div>

  <!-- Wizard -->
  <div id="wizard" role="dialog" aria-label="Planning Wizard">
    <div id="steps"></div>

    <!-- Step 1 -->
    <div id="step1" class="wizard-step">
      <h4>Step 1 â€” Create / Select User</h4>
      <div class="row" style="margin-bottom:6px;">
        <label>User: <select id="userSelect"></select></label>
        <input type="text" id="newUserName" placeholder="New user name"/>
        <button class="small-btn" id="btnAddUser">Add / Select</button>
      </div>
      <div class="muted">Create a new user or select an existing one. Required before continuing.</div>
    </div>

    <div id="step2" class="wizard-step" style="display:none">
      <h4>Step 2 â€” Select Fire Points</h4>
<button class="small-btn" id="btnUndoBatch">Undo last batch</button>

<div class="panel" id="histBox" style="margin-bottom:10px;">
  <div class="row" style="justify-content:space-between;align-items:center;">
    <div class="row" style="gap:8px;">
      <button class="small-btn" id="btnToggleHist">Historical dataâ€¦</button>
      <span class="muted">Optional: load & pick from detected points.</span>
    </div>
  </div>
  <div id="histPanel" style="display:none;margin-top:8px;">
    <h4>Step 2 â€” Choose Fire Points Time Span (RAW data)</h4>
      <div class="row"><span class="muted" id="tileDateHint">Data window available: (loadingâ€¦)</span></div>
      <div class="row" style="margin-top:4px;">
        Start: <input type="date" id="dataStart">
        End: <input type="date" id="dataEnd">
        <button class="small-btn" id="btnLoadTiles" disabled>Load data window</button>
      </div>
      <div class="legend-inline" style="margin-top:6px;">
        <div class="legend-item"><span class="dot" style="background:var(--warn);"></span> RAW point</div>
        <div class="legend-item"><span class="dot" style="background:var(--accent);"></span> Selected RAW</div>
        <div class="legend-item"><span class="dot" style="background:var(--custom);"></span> Custom point</div>
      </div>
      <div class="muted" style="margin-top:6px;">This window filters the historical detections to display and select from.</div>
  </div>
</div>

      <div class="row" style="margin-bottom:6px;">
        <button class="small-btn" id="btnRectSelect">Select by Rectangle</button>
      </div>
      <div class="muted">Leftâ€‘click RAW points to select/unselect. <b>Rightâ€‘click</b> empty map to add a custom point (purple). Click a custom point to edit/delete.</div>
    </div><!-- Step 4 -->
    <div id="step3" class="wizard-step" style="display:none">
      <h4>Step 3 â€” Observation Window & Default Interval</h4>
      <div class="row" id="obsDateRow"><span class="muted" id="obsHint">Observation window (example): 2025-01-01 â†’ 2025-01-20.</span></div>
      <div class="row" style="margin-top:4px;">
        Start: <input type="date" id="obsStart">
        End: <input type="date" id="obsEnd">
      </div>
      <div class="row" style="margin-top:6px;">
        <label>Default required interval (h)
          <input type="number" id="defaultInterval" min="1" step="1" value="4" style="width:80px;padding:5px"/>
        </label>
        <span class="muted">Per-point frequency in the list overrides this value.</span>
      </div>
    </div>

    <!-- Step 5 -->
    <div id="step4" class="wizard-step" style="display:none">
      <h4>Step 3 â€” Satellites</h4>
      <div class="row" style="margin-top:2px;">
        <label><input type="checkbox" id="chkShowTracks"/> Show ground track</label>
      </div>
      <div class="row" style="margin-top:4px;">
        <span class="muted" id="satDates">Observation window: â€”</span>
      </div>
      <div style="margin-top:6px;">
        <div class="muted" id="satSourceHint">Loading tracks/index.jsonâ€¦</div>
        <div class="listbox" id="satList" aria-label="Available satellites"></div>
      </div>
      <div class="row" style="margin-top:8px;justify-content:flex-end;gap:8px;">
        <button class="small-btn" id="btnSelectAllSats">Select all</button>
        <button class="small-btn outline" id="btnInvertSats">Invert</button>
        <button class="small-btn ghost" id="btnClearSats">Clear satellites</button>
        <button class="small-btn" id="btnExportTaskCSV">Export task request CSV</button>
      </div>
    </div>

    <div class="wizard-nav">
      <button class="small-btn ghost" id="btnPrev" disabled>Back</button>
      <button class="small-btn" id="btnNext" disabled>Next</button>
    </div>
  </div>

  <!-- Done modal -->
  <div id="doneOverlay" class="overlay hidden"></div>
  <div id="doneDialog" class="dialog hidden" role="dialog" aria-modal="true" aria-label="Complete">
    <h4>All set! What do you want to do next?</h4>
    <div class="muted">You can add another user, export all usersâ€™ CSV, or exit.</div>
    <div class="footer">
      <button class="small-btn ghost" id="btnDoneAddUser">Add another user</button>
      <button class="small-btn outline" id="btnDoneExportAll">Export all users CSV</button>
      <button class="small-btn danger" id="btnExit">Exit</button>
    </div>
  </div>

  <script>
    // =========================
    // Config / Globals
    // =========================
    const TILE_DIR = 'tiles';
    const TRACK_DIR = 'tracks';
    const OBS_DEFAULT_START = '2025-01-01';
    const OBS_DEFAULT_END   = '2025-01-20';
    const OBS_MIN = '2024-01-01';
    const OBS_MAX = '2026-12-31';

    let META=null, INDEX=null, TRACK_INDEX=null;
    let TILE_MIN_DATE=null, TILE_MAX_DATE=null;

    const users = {}; let currentUser=null;
    let wizardStep = 1;
    const steps = ['User','Select Points','Observation','Satellites'];
    const dataDates=[];   // RAW tiles dates
    const obsDates=[];    // observation window dates

    // Per-user satellites
    const satellitesByUser = {}; // { username: Set<string> }
    const selectedSats = new Set(); // mirror current user for compatibility
    function getCurrentSatSet(){
      if (!currentUser) return selectedSats;
      if (!satellitesByUser[currentUser]) satellitesByUser[currentUser] = new Set();
      return satellitesByUser[currentUser];
    }
    function syncSelectedSatsFromUser(){
      const set = getCurrentSatSet();
      selectedSats.clear();
      set.forEach(s => selectedSats.add(s));
    }

    // Map
    const canvasRenderer = L.canvas({ padding: 0.2 });
    const map = L.map('map', { preferCanvas: true, contextmenu: true }).setView([0, 0], 2);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {maxZoom:19,attribution:'&copy; OpenStreetMap & CARTO'}).addTo(map);

    // Layer for custom points
    const customLayer = L.layerGroup().addTo(map);
    const customMarkers = new Map(); // id -> marker

    // Helpers â€” dates
    function pad2(n){ return String(n).padStart(2,'0'); }
    function ymd_UTC(d){ return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth()+1)}-${pad2(d.getUTCDate())}`; }
    function parseYMD(s){ const [y,m,d]=s.split('-').map(Number); return new Date(Date.UTC(y,m-1,d)); }
    function listDays(start,end){ const out=[]; for(let d=parseYMD(start); d<=parseYMD(end); d.setUTCDate(d.getUTCDate()+1)) out.push(ymd_UTC(d)); return out; }

    function setStep(n){
      wizardStep=n;
      const stepsBar=document.getElementById('steps'); stepsBar.innerHTML='';
      for(let i=1;i<=steps.length;i++){
        const pill=document.createElement('span');
        pill.className='step-pill'+(i===n?' active':(i<n?' done':'')); pill.textContent=`${i}. ${steps[i-1]}`;
        stepsBar.appendChild(pill);
      }
      for(let i=1;i<=steps.length;i++){ document.getElementById('step'+i).style.display=(i===n?'block':'none'); }
      updateWizardButtons();
    }

    function updateWizardButtons(){
      const prev=document.getElementById('btnPrev');
      const next=document.getElementById('btnNext');
      prev.disabled=(wizardStep===1);
      let canNext=false;
      if(wizardStep===1){
        canNext=!!currentUser;
      }else if(wizardStep===2){
        canNext=(users[currentUser]||[]).length>0;
      }else if(wizardStep===3){
        const s=document.getElementById('obsStart').value;
        const e=document.getElementById('obsEnd').value;
        canNext=!!(s && e && e>=s);
      }else if(wizardStep===4){
        canNext=true;
      }
      next.disabled=!canNext; next.textContent=(wizardStep<steps.length?'Next':'Done');
    }

    // =========================
    // Tiles: grid helpers & loading
    // =========================
    function dLat(){ return (META.lat_max - META.lat_min) / META.ny; }
    function dLon(){ return (META.lon_max - META.lon_min) / META.nx; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function latToRow(lat){ let r=Math.floor((lat - META.lat_min)/dLat()); return clamp(r, 0, META.ny-1); }
    function lonToCol(lon){ let c=Math.floor((lon - META.lon_min)/dLon()); return clamp(c, 0, META.nx-1); }
    function rcRangeForBounds(bounds){
      const sw=bounds.getSouthWest(), ne=bounds.getNorthEast();
      let r0=latToRow(sw.lat), r1=latToRow(ne.lat); if(r1<r0)[r0,r1]=[r1,r0];
      let c0=lonToCol(sw.lng), c1=lonToCol(ne.lng); if(c1<c0)[c0,c1]=[c1,c0]; // fixed swap
      return { r0, r1, c0, c1 };
    }

    const MAX_CONCURRENT_FETCHES=10;
    const fetchQueue=[]; let inflight=0;
    function schedule(taskFn){ return new Promise((resolve,reject)=>{ fetchQueue.push({taskFn,resolve,reject}); pump(); }); }
    function pump(){
      while(inflight<MAX_CONCURRENT_FETCHES && fetchQueue.length){
        const {taskFn,resolve,reject}=fetchQueue.shift();
        inflight++; taskFn().then(v=>{inflight--;pump();resolve(v);}).catch(e=>{inflight--;pump();reject(e);});
      }
    }

    const tileCache=new Map(); // date -> Map("r|c" -> entry)
    function dateCache(d){ if(!tileCache.has(d)) tileCache.set(d,new Map()); return tileCache.get(d); }
    function rcKey(r,c){ return r+'|'+c; }
    function tilePath(d,r,c){ return `${TILE_DIR}/${d}/r${r}_c${c}.json`; }

    function idForPoint(date, lat, lon, time, idx){ const t=(time??'').toString().padStart(4,'0'); return `${date}|${t}|${lat}|${lon}|${idx}`; }
    function varGet(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    function baseStyle(){ return {renderer:canvasRenderer, radius:5, color:'#f39c12', fillColor:varGet('--warn'), fillOpacity:.9, weight:1}; }
    function selectedStyle(){ return {renderer:canvasRenderer, radius:6, color:varGet('--accent'), fillColor:varGet('--accent'), fillOpacity:.92, weight:2}; }
    function customStyle(){ const c=getComputedStyle(document.documentElement).getPropertyValue('--custom').trim(); return {renderer:canvasRenderer, radius:6, color:c, fillColor:c, fillOpacity:.95, weight:2}; }
    const b=v=>(v===undefined||v===null||v==='')?'â€”':v;

    function createMarker(pt){
      const m=L.circleMarker([pt.lat, pt.lon], baseStyle());
      m._rawId=pt.id;
      m.bindPopup(()=>`
        <div><b>RAW detection</b></div>
        <div>Date: ${b(pt.date)} Time: ${b(pt.time)}</div>
        <div>Brightness: ${b(pt.brightness)}</div>
        <div>Lat: ${pt.lat.toFixed(5)}, Lon: ${pt.lon.toFixed(5)}</div>
        <div style="margin-top:4px;"><em>Click to select/unselect.</em></div>
      `);
      m.on('click',()=>togglePoint(pt.id)); // left-click RAW points
      return m;
    }

    function loadTile(d,r,c){
      const cache=dateCache(d); const key=rcKey(r,c); const existed=cache.get(key);
      if(existed) return existed.promise;

      const entry={state:'loading', points:[], markers:[], layer:L.layerGroup(), added:false, promise:null};
      entry.promise = schedule(async()=>{
        const res=await fetch(tilePath(d,r,c), {cache:'force-cache'});
        if(!res.ok) throw new Error(`Tile not found ${d} r${r}_c${c} (${res.status})`);
        const js=await res.json();
        const raw=Array.isArray(js.points)?js.points:[];
        entry.points=raw.map((arr,i)=>({ id:idForPoint(d,+arr[0],+arr[1],arr[3]??'',i), date:d, lat:+arr[0], lon:+arr[1], brightness:arr[2]??'', time:arr[3]??'' }));
        for(const pt of entry.points){ const mk=createMarker(pt); entry.markers.push(mk); entry.layer.addLayer(mk); }
        entry.state='ready'; return entry;
      }).catch(err=>{ entry.state='error'; entry.error=err; throw err; });

      cache.set(key, entry); return entry.promise;
    }

    function addTile(entry){ if(!entry||entry.added||entry.state!=='ready')return; entry.layer.addTo(map); entry.added=true; restyleTileMarkers(entry); }
    function removeTile(entry){ if(!entry||!entry.added)return; try{ map.removeLayer(entry.layer);}catch(_){} entry.added=false; }
    function restyleTileMarkers(entry){
      const arr=users[currentUser]||[]; const sel=new Set(arr.filter(s=>!s.id.startsWith('custom|')).map(s=>s.id));
      for(const mk of entry.markers){ mk.setStyle(sel.has(mk._rawId)?selectedStyle():baseStyle()); }
    }

    // Restyle all loaded tile markers based on current selection (helps after undo)
    function restyleAllTiles(){
      for(const [,cache] of tileCache.entries()){
        for(const [,entry] of cache.entries()){
          if(entry && entry.added){ restyleTileMarkers(entry); }
        }
      }
    }

    function clearAllTiles(){ for(const [,cache] of tileCache.entries()){ for(const [,e] of cache.entries()){ removeTile(e); } } tileCache.clear(); }

    // Custom marker helpers
    function customTooltipText(p){
      const freq = (p.frequency==null || p.frequency==='') ? 'â€”' : p.frequency+'h';
      return `Custom\\n${p.lat.toFixed(4)}, ${p.lon.toFixed(4)}\\nFreq: ${freq}`;
    }
    function updateCustomMarkerTooltip(id){
      const mk = customMarkers.get(id);
      if(!mk) return;
      const p = (users[currentUser]||[]).find(x=>x.id===id);
      if(!p) return;
      const tt = mk.getTooltip();
      if(tt) tt.setContent(customTooltipText(p)); else mk.bindTooltip(customTooltipText(p), {sticky:true});
    }
    function createCustomMarker(id, lat, lon){
      const mk = L.circleMarker([lat, lon], customStyle());
      mk._cid = id;
      mk.on('click', ()=> openCustomMenu(mk));
      customLayer.addLayer(mk);
      customMarkers.set(id, mk);
      const p = (users[currentUser]||[]).find(x=>x.id===id);
      mk.bindTooltip(customTooltipText(p||{lat,lon,frequency:null}), {sticky:true});
      return mk;
    }
    function removeCustomMarker(id){
      const mk = customMarkers.get(id);
      if(mk){ try{ customLayer.removeLayer(mk); }catch(_){} customMarkers.delete(id); }
    }
    function rebuildCustomMarkersForCurrentUser(){
      customLayer.clearLayers(); customMarkers.clear();
      const arr = users[currentUser]||[];
      for(const p of arr){
        if(String(p.id).startsWith('custom|')){
          createCustomMarker(p.id, p.lat, p.lon);
        }
      }
    }

    function unstyleMarkerById(id){
      if(id.startsWith('custom|')){ removeCustomMarker(id); return true; }
      for(const [,cache] of tileCache.entries()){
        for(const [,entry] of cache.entries()){
          if(!entry.added) continue;
          const mk=entry.markers.find(m=>m._rawId===id);
          if(mk){ mk.setStyle(baseStyle()); return true; }
        }
      }
      return false;
    }

    async function dataMoveHandler(){
      if(!META||!INDEX||dataDates.length===0) return;
      const bnds=map.getBounds(); const {r0,r1,c0,c1}=rcRangeForBounds(bnds);

      const needed=new Map();
      for(const d of dataDates){
        const set=new Set(); const avail=INDEX[d]||[]; const has=new Set(avail.map(x=>rcKey(x[0],x[1])));
        for(let r=r0;r<=r1;r++){ for(let c=c0;c<=c1;c++){ const key=rcKey(r,c); if(has.has(key)) set.add(key); } }
        needed.set(d,set);
      }

      const promises=[];
      for(const d of dataDates){
        const set=needed.get(d); const cache=dateCache(d);
        for(const key of set){ if(!cache.has(key)){ const [r,c]=key.split('|').map(Number); promises.push(loadTile(d,r,c)); } }
      }
      await Promise.allSettled(promises);

      let total=0, ready=0, active=0, visiblePts=0;
      for(const [d,cache] of tileCache.entries()){
        for(const [key,entry] of cache.entries()){
          total++; if(entry.state==='ready') ready++;
          const shouldOn=dataDates.includes(d) && needed.get(d)?.has(key);
          if(shouldOn && entry.state==='ready'){ addTile(entry); active++; visiblePts+=entry.points.length; }
          else{ removeTile(entry); }
        }
      }
      document.getElementById('sideStatus').textContent=`Tiles ready: ${ready}/${total} | Active on map: ${active} | Visible RAW: ${visiblePts.toLocaleString()}`;
    }

    // =========================
    // Selection & sidebar
    // =========================
    const drawnItems=new L.FeatureGroup(); map.addLayer(drawnItems);
    const drawControl=new L.Control.Draw({
      draw:{polygon:false,circle:false,circlemarker:false,marker:false,polyline:false,rectangle:{repeatMode:false,showArea:false}},
      edit:{featureGroup:drawnItems,edit:false,remove:true}
    });
    let drawEnabled=false;
    function enableRectangleSelection(){
      if(drawEnabled) return; drawEnabled=true; map.addControl(drawControl);
      const drawer=new L.Draw.Rectangle(map, drawControl.options.draw.rectangle); drawer.enable();

function onCreated(e){
  const bounds = e.layer.getBounds();
  let addedRaw = 0;
  ensureUser(currentUser);

  // --- Quick tile pruning: maintain entry.bbox (computed on-demand once) ---
  function getEntryBBox(entry){
    if(entry.bbox) return entry.bbox;
    let minLat=  90, maxLat= -90, minLon=  999, maxLon= -999;
    if(entry.markers && entry.markers.length){
      for(const mk of entry.markers){
        const ll = mk.getLatLng();
        if(!ll) continue;
        if(ll.lat<minLat) minLat=ll.lat;
        if(ll.lat>maxLat) maxLat=ll.lat;
        if(ll.lng<minLon) minLon=ll.lng;
        if(ll.lng>maxLon) maxLon=ll.lng;
      }
      entry.bbox = L.latLngBounds(L.latLng(minLat,minLon), L.latLng(maxLat,maxLon));
      return entry.bbox;
    }
    // empty entry
    entry.bbox = L.latLngBounds(L.latLng(0,0), L.latLng(0,0));
    return entry.bbox;
  }

  // 1) Try RAW selection with pruning
  for(const [,cache] of tileCache.entries()){
    for(const [,entry] of cache.entries()){
      if(!entry.added) continue;
      const eb = getEntryBBox(entry);
      if(eb && !bounds.intersects(eb)) continue; // prune
      for(const mk of entry.markers){
        const ll = mk.getLatLng();
        if(!ll) continue;
        if(bounds.contains(ll)){
          const id = mk._rawId;
          const arr = users[currentUser];
          if(arr.findIndex(s=>s.id===id)===-1){
            arr.push({id,lat:ll.lat,lon:ll.lng,fire_count:1,frequency:null});
            try{ mk.setStyle(selectedStyle()); }catch(e){}
            addedRaw++;
          }
        }
      }
    }
  }

  if(addedRaw>0){
    refreshSelectedList();
    alert(`Added ${addedRaw} RAW point${addedRaw>1?'s':''} to user "${currentUser}".`);
    map.off(L.Draw.Event.CREATED,onCreated); drawer.disable(); map.removeControl(drawControl); drawEnabled=false; drawnItems.clearLayers();
    return;
  }

  // 2) Fixed-density fallback (1 point per 50 kmÂ²), with pre-estimation & confirmation
  const FIXED_DENSITY = 0.02; // pts/kmÂ²
  const MAX_PER_BATCH = 200;
  const CONFIRM_THRESHOLD = 150;
  const KM_PER_DEG = 111.32;
  const COS_MIN = 0.1;

  function kmPerDegLonAtLat(latDeg){
    return KM_PER_DEG * Math.max(Math.cos(latDeg*Math.PI/180), COS_MIN);
  }

  // Area estimate
  const sw = bounds.getSouthWest();
  const ne = bounds.getNorthEast();
  let lat1=sw.lat, lat2=ne.lat, lon1=sw.lng, lon2=ne.lng;
  function areaKm2(aLat1,aLat2,aLon1,aLon2){
    const latMid=(aLat1+aLat2)/2;
    const dlatKm=Math.abs(aLat2-aLat1)*KM_PER_DEG;
    const dlonKm=Math.abs(aLon2-aLon1)*kmPerDegLonAtLat(latMid);
    return dlatKm*dlonKm;
  }
  let est = 0;
  if(lon2<lon1){
    est += areaKm2(lat1,lat2,lon1,180);
    est += areaKm2(lat1,lat2,-180,lon2);
  }else{
    est += areaKm2(lat1,lat2,lon1,lon2);
  }

const nEstRaw = est * FIXED_DENSITY;
const nPred = Math.min(Math.round(nEstRaw), MAX_PER_BATCH);
if (nPred >= CONFIRM_THRESHOLD) {
  const over = nPred < Math.round(nEstRaw) ? ` (capped at ${MAX_PER_BATCH})` : '';
  const ok = confirm(`This will create about ${nPred} points${over}. Continue?`);
  if (!ok) {
    map.off(L.Draw.Event.CREATED,onCreated); drawer.disable(); map.removeControl(drawControl); drawEnabled=false; drawnItems.clearLayers();
    return;
  }
}

  // Generate grid with dynamic stepLon per row & dedupe
  const existing = new Set(); // rounded "lat|lon" of all existing points for this user
  for(const p of (users[currentUser]||[])){
    const key = `${p.lat.toFixed(6)}|${p.lon.toFixed(6)}`;
    existing.add(key);
  }

  function addGrid(aLat1,aLat2,aLon1,aLon2, idsOut){
    const dlatKm=Math.abs(aLat2-aLat1)*KM_PER_DEG;
    const dlonKmMid=Math.abs(aLon2-aLon1)*kmPerDegLonAtLat((aLat1+aLat2)/2);
    let nEstLocal = (dlatKm*dlonKmMid) * FIXED_DENSITY;

    let sKm = Math.sqrt(1/Math.max(FIXED_DENSITY,1e-9));
    if(nEstLocal > MAX_PER_BATCH){
      const scale = Math.sqrt(nEstLocal / MAX_PER_BATCH);
      sKm *= scale;
      nEstLocal = MAX_PER_BATCH;
    }
    const stepLat = sKm / KM_PER_DEG;
    const laStart = Math.min(aLat1,aLat2) + 0.5*stepLat, laEnd = Math.max(aLat1,aLat2);

    for(let la = laStart; la <= laEnd; la += stepLat){
      const stepLon = sKm / kmPerDegLonAtLat(la); // dynamic per row
      const loStart = Math.min(aLon1,aLon2) + 0.5*stepLon, loEnd = Math.max(aLon1,aLon2);
      for(let lo = loStart; lo <= loEnd; lo += stepLon){
        const key = `${la.toFixed(6)}|${lo.toFixed(6)}`;
        if(existing.has(key)) continue; // dedupe with existing
        const id = addCustomPoint(la, lo, null);
        if(id){
          existing.add(key);
          idsOut.push(id);
          if(idsOut.length >= MAX_PER_BATCH) return;
        }
      }
      if(idsOut.length >= MAX_PER_BATCH) return;
    }
  }

  const batchIds = [];
  if(lon2 < lon1){
    addGrid(lat1,lat2,lon1,180,batchIds);
    if(batchIds.length < MAX_PER_BATCH) addGrid(lat1,lat2,-180,lon2,batchIds);
  }else{
    addGrid(lat1,lat2,lon1,lon2,batchIds);
  }

  window._lastBatchIDs = batchIds.slice(); // save for undo
  refreshSelectedList();
  const msg = batchIds.length>0 ? `Created ${batchIds.length} custom point${batchIds.length>1?'s':''} by density.` : 'No points created.';
  alert(msg);

  map.off(L.Draw.Event.CREATED,onCreated);
  drawer.disable();
  map.removeControl(drawControl);
  drawEnabled=false;
  drawnItems.clearLayers();
}

      map.on(L.Draw.Event.CREATED,onCreated);
    }

    function ensureUser(name){ if(!users[name]) users[name]=[]; }
    function togglePoint(id){
      if(!currentUser){ alert('Please add/select a user first.'); return; }
      ensureUser(currentUser);
      const arr=users[currentUser]; const idx=arr.findIndex(p=>p.id===id);

      let found=null;
      for(const [,cache] of tileCache.entries()){
        for(const [,entry] of cache.entries()){
          if(!entry.added) continue;
          const mk=entry.markers.find(m=>m._rawId===id);
          if(mk){ found=mk; break; }
        } if(found) break;
      }
      if(!found) return;
      const ll=found.getLatLng();

      if(idx===-1){ arr.push({id,lat:ll.lat,lon:ll.lng,fire_count:1,frequency:null}); found.setStyle(selectedStyle()); }
      else{ arr.splice(idx,1); found.setStyle(baseStyle()); }

      refreshSelectedList();
    }

    function addCustomPoint(lat, lon, frequency){
      ensureUser(currentUser);
      const id = `custom|${lat}|${lon}|${Math.random().toString(36).slice(2,8)}`;
      users[currentUser].push({id,lat,lon,fire_count:1,frequency:frequency ?? null});
      createCustomMarker(id, lat, lon);
      refreshSelectedList();
      return id;
    }

    function openCustomMenu(marker){
      if(!currentUser) return;
      const id = marker._cid;
      const arr = users[currentUser] || [];
      const idx = arr.findIndex(p=>p.id===id);
      if(idx===-1) return;
      const p = arr[idx];
      const latlng = marker.getLatLng();
      const html = `
        <div style="min-width:240px;">
          <div><b>Custom point</b></div>
          <div>Lat: ${p.lat.toFixed(5)}, Lon: ${p.lon.toFixed(5)}</div>
          <div style="margin-top:6px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
            <label>Freq (h) <input id="menuFreq" type="number" min="0" step="1" style="width:80px" value="${p.frequency ?? ''}"/></label>
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;justify-content:flex-end;">
            <button id="menuDelete" class="small-btn danger">Delete</button>
            <button id="menuSave" class="small-btn">Save</button>
            <button id="menuCancel" class="small-btn ghost">Cancel</button>
          </div>
        </div>`;
      if(window._customMenu){ map.closePopup(window._customMenu); }
      const pop = L.popup().setLatLng(latlng).setContent(html).openOn(map);
      window._customMenu = pop;
      setTimeout(()=>{
        const del = document.getElementById('menuDelete');
        const save = document.getElementById('menuSave');
        const cancel = document.getElementById('menuCancel');
        const freq = document.getElementById('menuFreq');
        if(del) del.addEventListener('click', ()=>{
          arr.splice(idx,1);
          removeCustomMarker(id);
          refreshSelectedList();
          try{ map.closePopup(pop); }catch(_){}
        });
        if(save) save.addEventListener('click', ()=>{
          const val = (freq && freq.value!=='') ? Math.max(0, Math.floor(+freq.value)) : null;
          arr[idx].frequency = val;
          updateCustomMarkerTooltip(id);
          refreshSelectedList();
          try{ map.closePopup(pop); }catch(_){}
        });
        if(cancel) cancel.addEventListener('click', ()=>{
          try{ map.closePopup(pop); }catch(_){}
        });
      },0);
    }

    function refreshSelectedList(){
      const tbody=document.getElementById('selected-tbody'); tbody.innerHTML='';
      const arr=users[currentUser]||[];
      arr.forEach((p,i)=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`
          <td class="check-cell"><input type="checkbox" class="row-check" data-id="${p.id}"/></td>
          <td>${i+1}</td>
          <td>${p.lat.toFixed(5)}</td>
          <td>${p.lon.toFixed(5)}</td>
          <td>${p.fire_count}</td>
          <td><input type="number" min="0" step="1" value="${p.frequency ?? ''}" data-id="${p.id}" class="freq-input" placeholder="e.g., 12"/></td>
          <td><button class="small-btn danger" data-id="${p.id}">Remove</button></td>`;
        tbody.appendChild(tr);
      });

      tbody.querySelectorAll('.freq-input').forEach(inp=>{
        inp.addEventListener('input',e=>{
          const id=e.target.getAttribute('data-id');
          const v=e.target.value===''?null:Math.max(0,Math.round(+e.target.value));
          const idx=(users[currentUser]||[]).findIndex(p=>p.id===id);
          if(idx!==-1) users[currentUser][idx].frequency=v;
          if(String(id).startsWith('custom|')) updateCustomMarkerTooltip(id);
        });
      });
      tbody.querySelectorAll('button.small-btn.danger').forEach(btn=>{
        btn.addEventListener('click',e=>{
          const id=e.target.getAttribute('data-id');
          const arr=users[currentUser]||[]; const idx=arr.findIndex(p=>p.id===id);
          if(idx!==-1){
            arr.splice(idx,1);
            unstyleMarkerById(id);
            refreshSelectedList();
          }
        });
      });

      document.getElementById('checkAllRows').checked=false;
      updateWizardButtons();
    }

    function removeSelectedRows(){
      const tbody=document.getElementById('selected-tbody');
      const ids=Array.from(tbody.querySelectorAll('.row-check:checked')).map(cb=>cb.getAttribute('data-id'));
      if(!ids.length) return;
      const set=new Set(ids); const arr=users[currentUser]||[];
      for(const id of set) unstyleMarkerById(id);
      users[currentUser]=arr.filter(p=>!set.has(p.id));
      refreshSelectedList();
    }
    function clearAllRows(){
      if(!currentUser) return;
      const arr=users[currentUser]||[]; if(!arr.length) return;
      const ok=confirm(`Remove ALL ${arr.length} points for user "${currentUser}"?`); if(!ok) return;
      for(const p of arr) unstyleMarkerById(p.id);
      users[currentUser]=[]; refreshSelectedList();
    }

    // =========================
    // Satellites / tracks (Step 5)
    // =========================
    function satColor(name){ let h=0; for(let i=0;i<name.length;i++){ h=(h*31 + name.charCodeAt(i)) % 360; } return `hsl(${h},70%,45%)`; }
    function trackKey(date,sat){ return `${date}|${sat}`; }
    function trackPath(date,sat){ return `${TRACK_DIR}/${date}/${encodeURIComponent(sat)}.json`; }

    const trackCache = new Map(); // date|sat -> {state, layer, promise}

    function loadTrack(date,sat){
      const key=trackKey(date,sat); const existed=trackCache.get(key);
      if(existed) return existed.promise;
      const entry={state:'loading', layer:L.layerGroup(), promise:null};
      entry.promise = schedule(async()=>{
        const res=await fetch(trackPath(date,sat), {cache:'force-cache'});
        if(!res.ok) throw new Error(`Track not found ${date} ${sat} (${res.status})`);
        const js=await res.json();
        const color=satColor(sat);

        if (Array.isArray(js.segments)) {
          for (const seg of js.segments) {
            const latlngs = seg.map(p => [ +p[0], +p[1] ]);
            const pl = L.polyline(latlngs, {renderer:canvasRenderer,weight:2,opacity:.9,color});
            pl.bindTooltip(`${sat} ${date}`,{sticky:true});
            entry.layer.addLayer(pl);
          }
        } else if (Array.isArray(js.lats) && Array.isArray(js.lons)) {
          const n = Math.min(js.lats.length, js.lons.length);
          const latlngs = [];
          for (let i=0;i<n;i++) latlngs.push([ +js.lats[i], +js.lons[i] ]);
          const pl = L.polyline(latlngs, {renderer:canvasRenderer,weight:2,opacity:.9,color});
          pl.bindTooltip(`${sat} ${date}`,{sticky:true});
          entry.layer.addLayer(pl);
        }

        entry.state='ready'; return entry;
      }).catch(err=>{ entry.state='error'; entry.error=err; throw err; });
      trackCache.set(key,entry); return entry.promise;
    }
    function clearAllTrackLayers(){ for(const entry of trackCache.values()){ try{ map.removeLayer(entry.layer);}catch(_){} } }
    function addTrack(entry){ if(!entry||entry.state!=='ready')return; if(map.hasLayer(entry.layer))return; entry.layer.addTo(map); }
    function rebuildTracksOnMap(){
      const show=document.getElementById('chkShowTracks').checked;
      clearAllTrackLayers();
      if(!show || obsDates.length===0) return;

      syncSelectedSatsFromUser();
      if(selectedSats.size===0) return;

      const promises=[];
      for(const d of obsDates){ for(const sat of selectedSats){ promises.push(loadTrack(d,sat)); } }
      Promise.allSettled(promises).then(()=>{
        for(const d of obsDates){ for(const sat of selectedSats){ const e=trackCache.get(trackKey(d,sat)); if(e&&e.state==='ready') addTrack(e); } }
      });
    }
    function buildSatelliteList(){
      const box=document.getElementById('satList'); const hint=document.getElementById('satSourceHint');
      box.innerHTML='';
      if(!TRACK_INDEX){ hint.textContent='tracks/index.json not loaded.'; return; }
      if(obsDates.length===0){ hint.textContent='Set observation window in Step 4.'; return; }
      const set=new Set(); for(const d of obsDates){ (TRACK_INDEX[d]||[]).forEach(s=>set.add(s)); }
      if(set.size===0){ hint.textContent='No tracks available for chosen observation window.'; return; }
      hint.textContent='Select satellites to overlay ground tracks:';

      const sats = Array.from(set).sort((a,b)=>a.localeCompare(b));
      const userSet = getCurrentSatSet();

      for(const s of sats){
        const row=document.createElement('div'); row.className='sat-item';
        const color=satColor(s);
        row.innerHTML=`
          <label style="display:flex;align-items:center;gap:8px;">
            <input type="checkbox" class="sat-check" value="${s}"/>
            <span class="sat-chip" style="border-color:${color};color:${color}">${s}</span>
          </label>`;
        box.appendChild(row);
      }

      syncSelectedSatsFromUser();
      box.querySelectorAll('.sat-check').forEach(cb=>{
        cb.checked = userSet.has(cb.value);
        cb.addEventListener('change', e=>{
          const name = e.target.value;
          if (e.target.checked) {
            userSet.add(name);
            selectedSats.add(name);
          } else {
            userSet.delete(name);
            selectedSats.delete(name);
          }
          rebuildTracksOnMap();
        });
      });
    }

    function selectAllSatellites(){
      const box=document.getElementById('satList');
      const checks=box.querySelectorAll('.sat-check');
      if(!checks.length){ alert('No satellites available for the current observation window.'); return; }
      const userSet=getCurrentSatSet();
      // Set all checked, then rebuild sets from UI
      checks.forEach(cb=>{ cb.checked=true; });
      userSet.clear(); selectedSats.clear();
      checks.forEach(cb=>{ userSet.add(cb.value); selectedSats.add(cb.value); });
      rebuildTracksOnMap();
    }
    function invertSatellites(){
      const box=document.getElementById('satList');
      const checks=box.querySelectorAll('.sat-check');
      if(!checks.length){ alert('No satellites available for the current observation window.'); return; }
      const userSet=getCurrentSatSet();
      checks.forEach(cb=>{ cb.checked=!cb.checked; });
      // Rebuild sets from UI state
      userSet.clear(); selectedSats.clear();
      checks.forEach(cb=>{ if(cb.checked){ userSet.add(cb.value); selectedSats.add(cb.value); } });
      rebuildTracksOnMap();
    }

    // =========================
    // Exports
    // =========================
    function toCSV(rows){ const esc=s=>'\"'+String(s).replace(/\"/g,'\"\"')+'\"'; return rows.map(r=>r.map(esc).join(',')).join('\\n'); }
    function downloadCSV(filename, rows){ const blob=new Blob([toCSV(rows)],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url); }
    function exportCurrentUser(){
      if(!currentUser){ alert('Please select a user.'); return; }
      const rows=[["username","lat","lon","fire_count","frequency_hours"]];
      for(const p of (users[currentUser]||[])) rows.push([currentUser,p.lat,p.lon,p.fire_count,p.frequency??'' ]);
      downloadCSV(`${currentUser}_selected_raw_points.csv`, rows);
    }
    function exportAllUsers() {
      if (obsDates.length === 0) {
        alert('Please set the observation window in Step 4.');
        return;
      }
      const start = obsDates[0] + ' 00:00:00Z';
      const end   = obsDates[obsDates.length - 1] + ' 23:59:59Z';
      const defInt = Math.max(1, Math.floor(+document.getElementById('defaultInterval').value || 4));

      const rows = [[
        'user','window_start_utc','window_end_utc','satellites','point_id','lat','lon','required_interval_hours'
      ]];

      let count = 0;
      for (const [uname, arr] of Object.entries(users)) {
        const satStr = [...(satellitesByUser[uname] || new Set())].join(';');
        for (const p of arr) {
          const req = (p.frequency == null || p.frequency === '') ? defInt : p.frequency;
          rows.push([uname, start, end, satStr, p.id, p.lat, p.lon, req]);
          count++;
        }
      }
      if (count === 0) { alert('No points selected for any user.'); return; }
      const fname = `task_request_ALL_${obsDates[0]}_${obsDates[obsDates.length-1]}.csv`;
      downloadCSV(fname, rows);
      const statusEl = document.getElementById('exportStatus');
      if (statusEl) statusEl.textContent = `Exported ${count} task rows across ${Object.keys(users).length} user(s).`;
    }
    function exportTaskCSV(){
      if(!currentUser){ alert('Please select a user.'); return; }
      if((users[currentUser]||[]).length===0){ alert('No points for current user.'); return; }
      if(obsDates.length===0){ alert('Set observation window in Step 4.'); return; }
      const start=obsDates[0] + ' 00:00:00Z';
      const end=obsDates[obsDates.length-1] + ' 23:59:59Z';
      const satStr=[...getCurrentSatSet()].join(';');
      const def=Math.max(1,Math.floor(+document.getElementById('defaultInterval').value||4));
      const rows=[[ 'user','window_start_utc','window_end_utc','satellites','point_id','lat','lon','required_interval_hours' ]];
      for(const p of (users[currentUser]||[])){ const req=(p.frequency==null||p.frequency==='')?def:p.frequency; rows.push([ currentUser,start,end,satStr,p.id,p.lat,p.lon,req ]); }
      downloadCSV(`task_request_${currentUser||'user'}_${obsDates[0]}_${obsDates[obsDates.length-1]}.csv`, rows);
    }

    // =========================
    // Right-click add custom point
    // =========================
    let pendingPopup=null;
    function showAddCustomPopup(latlng){
      if(!currentUser){ alert('Please add/select a user first.'); return; }
      const lat=+latlng.lat.toFixed(5), lon=+latlng.lng.toFixed(5);
      const html = `
        <div style="min-width:220px;">
          <div><b>Create custom point here?</b></div>
          <div>Lat: ${lat}, Lon: ${lon}</div>
          <div style="margin-top:6px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
            <label>Freq (h) <input id="popupFreq" type="number" min="0" step="1" style="width:80px"/></label>
            <button id="popupAdd" class="small-btn">Add</button>
            <button id="popupCancel" class="small-btn ghost">Cancel</button>
          </div>
        </div>`;
      if(pendingPopup){ map.closePopup(pendingPopup); pendingPopup=null; }
      pendingPopup = L.popup().setLatLng(latlng).setContent(html).openOn(map);
      setTimeout(()=>{
        const addBtn = document.getElementById('popupAdd');
        const cancelBtn = document.getElementById('popupCancel');
        const freqInp = document.getElementById('popupFreq');
        if(addBtn){
          addBtn.addEventListener('click', ()=>{
            const freqVal = (freqInp && freqInp.value!=='' ? Math.max(0, Math.floor(+freqInp.value)) : null);
            addCustomPoint(lat, lon, freqVal);
            map.closePopup(pendingPopup); pendingPopup=null;
          });
        }
        if(cancelBtn){ cancelBtn.addEventListener('click', ()=>{ map.closePopup(pendingPopup); pendingPopup=null; }); }
      },0);
    }

    map.on('contextmenu', (e)=>{
      if(e.originalEvent){ e.originalEvent.preventDefault(); }
      showAddCustomPopup(e.latlng);
    });

    // =========================
    // Done modal & Wizard nav
    // =========================
    function showDone(){ document.getElementById('doneOverlay').classList.remove('hidden'); document.getElementById('doneDialog').classList.remove('hidden'); }
    function hideDone(){ document.getElementById('doneOverlay').classList.add('hidden'); document.getElementById('doneDialog').classList.add('hidden'); }
    function tryExit(){
      window.close();
      setTimeout(()=>{
        document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font:16px system-ui;">You can close this tab now.</div>';
      }, 300);
    }

    function onPrev(){ if(wizardStep>1){ setStep(wizardStep-1); } }
    function onNext(){
      if(wizardStep===1){
        if(!currentUser){ alert('Please create or select a user.'); return; }
        setStep(2);
      }else if(wizardStep===2){
        if((users[currentUser]||[]).length===0){ alert('Please select at least one point.'); return; }
        setStep(3);
      }else if(wizardStep===3){
        const s=document.getElementById('obsStart').value;
        const e=document.getElementById('obsEnd').value;
        if(!s||!e||e<s){ alert('Please set a valid observation window.'); return; }
        obsDates.length=0; listDays(s,e).forEach(d=>obsDates.push(d));
        document.getElementById('satDates').textContent=`Observation window: ${s} â†’ ${e}`;
        rebuildSatList();
        rebuildTracksOnMap();
        setStep(4);
      }else if(wizardStep===4){
        showDone();
      }
    }

    // =========================
    // Wiring
    // =========================
    document.getElementById('btnEnter').addEventListener('click',()=>{ document.getElementById('cover').classList.add('hidden'); });

    function refreshUserDropdown(){
      const sel=document.getElementById('userSelect'); const prev=sel.value; sel.innerHTML='';
      Object.keys(users).forEach(u=>{ const opt=document.createElement('option'); opt.value=u; opt.textContent=u; sel.appendChild(opt); });
      if(users[prev]) sel.value=prev;
      if(!sel.value && Object.keys(users).length) sel.value=Object.keys(users)[0];
      currentUser=sel.value||null;

      syncSelectedSatsFromUser();
      buildSatelliteList();
      rebuildTracksOnMap();
      rebuildCustomMarkersForCurrentUser();

      refreshSelectedList(); updateWizardButtons();
      for(const [,cache] of tileCache.entries()){ for(const [,entry] of cache.entries()){ if(entry.added) restyleTileMarkers(entry); } }
    }

    document.getElementById('btnAddUser').addEventListener('click',()=>{
      const name=(document.getElementById('newUserName').value||'').trim();
      const sel=document.getElementById('userSelect');
      if(name){
        if(!users[name]) users[name]=[];
        if(!satellitesByUser[name]) satellitesByUser[name] = new Set();
        sel.value=name; currentUser=name; document.getElementById('newUserName').value='';
        refreshUserDropdown();
      }else{
        currentUser=sel.value||null;
        refreshUserDropdown();
      }
    });

    document.getElementById('btnToggleHist').addEventListener('click', ()=>{
      const p = document.getElementById('histPanel');
      if(p) p.style.display = (p.style.display==='none'||p.style.display==='') ? 'block' : 'none';
    });

    document.getElementById('userSelect').addEventListener('change',e=>{
      currentUser=e.target.value||null;
      refreshUserDropdown();
    });

    document.getElementById('btnLoadTiles').addEventListener('click', async ()=>{
      const s=document.getElementById('dataStart').value;
      const e=document.getElementById('dataEnd').value;
      if(!s||!e||e<s){ alert('Choose a valid data window.'); return; }
      const all=Object.keys(INDEX||{}).sort();
      if(s < TILE_MIN_DATE || e > TILE_MAX_DATE){ alert('Selected dates must be within available data window.'); return; }
      dataDates.length=0; listDays(s,e).forEach(d=>{ if(INDEX[d]) dataDates.push(d); });
      clearAllTiles();
      document.getElementById('sideStatus').textContent='Loading tiles...';
      const b=L.latLngBounds([META.lat_min, META.lon_min],[META.lat_max, META.lon_max]); map.fitBounds(b.pad(0.1));
      await dataMoveHandler(); updateWizardButtons();
    });

    document.getElementById('btnRectSelect').addEventListener('click',()=>{
      if(!currentUser){ alert('Please add/select a user first.'); return; }
      enableRectangleSelection();
    });
    document.getElementById('btnSetAll12').addEventListener('click',()=>{ if(!currentUser) return; (users[currentUser]||[]).forEach(p=>p.frequency=12); refreshSelectedList(); });
    document.getElementById('btnExportUser').addEventListener('click',exportCurrentUser);
    document.getElementById('btnExportAll').addEventListener('click',exportAllUsers);
    document.getElementById('btnRemoveSelected').addEventListener('click',removeSelectedRows);
    document.getElementById('btnClearAll').addEventListener('click',clearAllRows);
    document.getElementById('checkAllRows').addEventListener('change',e=>{
      const checked=e.target.checked; document.querySelectorAll('#selected-tbody .row-check').forEach(cb=>cb.checked=checked);
    });
    document.getElementById('btnAddCustom').addEventListener('click',()=>{
      if(!currentUser){ alert('Please add/select a user first.'); return; }
      const lat=parseFloat(document.getElementById('customLat').value);
      const lon=parseFloat(document.getElementById('customLon').value);
      if(!Number.isFinite(lat)||!Number.isFinite(lon)){ alert('Please input valid lat/lon.'); return; }
      addCustomPoint(lat, lon, null);
    });

    document.getElementById('chkShowTracks').addEventListener('change',rebuildTracksOnMap);
    document.getElementById('btnSelectAllSats').addEventListener('click',selectAllSatellites);
    document.getElementById('btnInvertSats').addEventListener('click',invertSatellites);
    document.getElementById('btnClearSats').addEventListener('click',()=>{
      const set = getCurrentSatSet();
      set.clear();
      selectedSats.clear();
      document.querySelectorAll('#satList .sat-check').forEach(cb=>cb.checked=false);
      rebuildTracksOnMap();
    });
    document.getElementById('btnExportTaskCSV').addEventListener('click',exportTaskCSV);

    document.getElementById('doneOverlay').addEventListener('click', hideDone);
    document.getElementById('btnDoneAddUser').addEventListener('click', ()=>{ hideDone(); setStep(1); document.getElementById('newUserName').focus(); });
    document.getElementById('btnDoneExportAll').addEventListener('click', ()=>{ exportAllUsers(); hideDone(); });
    document.getElementById('btnExit').addEventListener('click', tryExit);

    document.getElementById('btnPrev').addEventListener('click',onPrev);
    document.getElementById('btnNext').addEventListener('click',onNext);

    map.on('moveend', dataMoveHandler);
    map.on('zoomend', dataMoveHandler);

    // Boot
    (async function boot(){
      try{
        const [m,i]=await Promise.all([
          fetch(`${TILE_DIR}/meta.json`,{cache:'no-cache'}).then(r=>r.json()),
          fetch(`${TILE_DIR}/index.json`,{cache:'no-cache'}).then(r=>r.json())
        ]);
        META=m; INDEX=i;
        const days=Object.keys(INDEX).sort();
        TILE_MIN_DATE=days[0]; TILE_MAX_DATE=days[days.length-1];
        const hint=document.getElementById('tileDateHint');
        hint.textContent=`Data window available: ${TILE_MIN_DATE} â†’ ${TILE_MAX_DATE} (inclusive)`;
        const ds=document.getElementById('dataStart'), de=document.getElementById('dataEnd');
        ds.min=TILE_MIN_DATE; ds.max=TILE_MAX_DATE; de.min=TILE_MIN_DATE; de.max=TILE_MAX_DATE;
        ds.value=TILE_MIN_DATE; de.value=TILE_MAX_DATE;
        document.getElementById('btnLoadTiles').disabled=false;
        document.getElementById('sideStatus').textContent=`Grid nx=${META.nx}, ny=${META.ny}`;
        const os=document.getElementById('obsStart'), oe=document.getElementById('obsEnd');
        if(os&&oe){ os.min=OBS_MIN; os.max=OBS_MAX; oe.min=OBS_MIN; oe.max=OBS_MAX; }
        const b=L.latLngBounds([META.lat_min, META.lon_min],[META.lat_max, META.lon_max]); map.fitBounds(b.pad(0.1));
      }catch(e){
        document.getElementById('tileDateHint').textContent='Failed to load tiles meta/index.'; console.error(e);
      }

      try{
        const t=await fetch(`${TRACK_DIR}/index.json`,{cache:'no-cache'});
        if(t.ok){ TRACK_INDEX=await t.json(); document.getElementById('satSourceHint').textContent='Tracks index loaded.'; }
        else{ document.getElementById('satSourceHint').textContent='tracks/index.json not found.'; }
      }catch(e){
        document.getElementById('satSourceHint').textContent='tracks/index.json not found.'; console.warn('Tracks index load failed',e);
      }

      users['User1']=[]; satellitesByUser['User1']=new Set(); currentUser='User1';
      refreshUserDropdown();

      const s=document.getElementById('obsStart'), e=document.getElementById('obsEnd');
      s.value=OBS_DEFAULT_START; e.value=OBS_DEFAULT_END;
      document.getElementById('obsHint').textContent = `Observation window (example): ${OBS_DEFAULT_START} â†’ ${OBS_DEFAULT_END}. You can change anytime.`;

      setStep(1);
    })();
  </script>

<script>
// ===== Batch tracking & Undo =====
window._lastBatchIDs = [];

function undoLastBatch(){
  if(!_lastBatchIDs || _lastBatchIDs.length===0){
    alert('Nothing to undo.');
    return;
  }
  if(!currentUser){ alert('No active user.'); return; }
  const ids = new Set(_lastBatchIDs);
  const arr = users[currentUser] || [];
  const kept = [];
  for(const p of arr){
    if(ids.has(p.id)){
      // remove marker if custom
      if (typeof customMarkers !== 'undefined' && customMarkers.has(p.id)) {
        const mk = customMarkers.get(p.id);
        try{ customLayer.removeLayer(mk); }catch(e){}
        try{ if(typeof map!=='undefined' && map.hasLayer(mk)) map.removeLayer(mk); }catch(e){}
        customMarkers.delete(p.id);
      }
    }else{
      kept.push(p);
    }
  }
  users[currentUser] = kept;
  _lastBatchIDs = [];
  // Restyle RAW markers that might have been part of the batch
  if(typeof restyleAllTiles==='function'){ restyleAllTiles(); }
  refreshSelectedList();
  alert('Last batch removed.');
}

document.addEventListener('DOMContentLoaded', ()=>{
  const btn = document.getElementById('btnUndoBatch');
  if(btn) btn.addEventListener('click', undoLastBatch);
});
</script>

</body>
</html>
